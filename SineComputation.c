/*
 ============================================================================
 Name        : SineComputation.c
 Author      : 
 Version     :
 Copyright   : Your copyright notice
 Description : Hello World in C, Ansi-style
 ============================================================================
 */

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <sys/time.h>
#include <stdint.h>

double taylorSine(double value, int accuracy) {
	double i = 1;
	double q = value * value;
	double sine = value;
	double nextTerm = value;
	double sign = -1;
	double accVal = 1 / pow(10, accuracy);

	while (fabs(nextTerm) > accVal) {
		nextTerm = nextTerm * q / (2 * i * (2 * i + 1));
		sine = sine + sign * nextTerm;
		sign = -sign;
		i++;
	}
	return sine;
}

double arcTans[] = { 0.7853981633974482789994908671360462903976,
		0.4636476090008060935154787784995278343558,
		0.2449786631268641434733268624768243171275,
		0.1243549945467614381566789916178095154464,
		0.0624188099959573500230547438150097150356,
		0.0312398334302682774421544564802388777025,
		0.0156237286204768312941615349132007395383,
		0.0078123410601011111439873069173245312413,
		0.0039062301319669717573901390750279460917,
		0.0019531225164788187584341550007138721412,
		0.0009765621895593194594364927496599193546,
		0.0004882812111948982899262139412144279049,
		0.0002441406201493617712447448120371973346,
		0.0001220703118936702078530659454358442417,
		0.0000610351561742087725935014541622791739,
		0.0000305175781155260957271547345159845577,
		0.0000152587890613157615423778681873479002,
		0.0000076293945311019699810389967098434028,
		0.0000038146972656064961417507561819428830,
		0.0000019073486328101869647792853193490892,
		0.0000009536743164059608441276310632217506,
		0.0000004768371582030888422810640820542760,
		0.0000002384185791015579736676881098325631,
		0.0000001192092895507806808997385635169597,
		0.0000000596046447753905522081060953335646,
		0.0000000298023223876953025738326493636679,
		0.0000000149011611938476545956387748939447,
		0.0000000074505805969238281250000000000000,
		0.0000000037252902984619140625000000000000,
		0.0000000018626451492309570312500000000000,
		0.0000000009313225746154785156250000000000,
		0.0000000004656612873077392578125000000000,
		0.0000000002328306436538696289062500000000,
		0.0000000001164153218269348144531250000000,
		0.0000000000582076609134674072265625000000,
		0.0000000000291038304567337036132812500000,
		0.0000000000145519152283668518066406250000,
		0.0000000000072759576141834259033203125000,
		0.0000000000036379788070917129516601562500,
		0.0000000000018189894035458564758300781250,
		0.0000000000009094947017729282379150390625,
		0.0000000000004547473508864641189575195312,
		0.0000000000002273736754432320594787597656,
		0.0000000000001136868377216160297393798828,
		0.0000000000000568434188608080148696899414,
		0.0000000000000284217094304040074348449707,
		0.0000000000000142108547152020037174224854,
		0.0000000000000071054273576010018587112427,
		0.0000000000000035527136788005009293556213,
		0.0000000000000017763568394002504646778107,
		0.0000000000000008881784197001252323389053,
		0.0000000000000004440892098500626161694527,
		0.0000000000000002220446049250313080847263,
		0.0000000000000001110223024625156540423632,
		0.0000000000000000555111512312578270211816,
		0.0000000000000000277555756156289135105908,
		0.0000000000000000138777878078144567552954,
		0.0000000000000000069388939039072283776477,
		0.0000000000000000034694469519536141888238,
		0.0000000000000000017347234759768070944119,
		0.0000000000000000008673617379884035472060,
		0.0000000000000000004336808689942017736030,
		0.0000000000000000002168404344971008868015,
		0.0000000000000000001084202172485504434007,
		0.0000000000000000000542101086242752217004,
		0.0000000000000000000271050543121376108502,
		0.0000000000000000000135525271560688054251,
		0.0000000000000000000067762635780344027125,
		0.0000000000000000000033881317890172013563,
		0.0000000000000000000016940658945086006781,
		0.0000000000000000000008470329472543003391,
		0.0000000000000000000004235164736271501695,
		0.0000000000000000000002117582368135750848,
		0.0000000000000000000001058791184067875424,
		0.0000000000000000000000529395592033937712,
		0.0000000000000000000000264697796016968856,
		0.0000000000000000000000132348898008484428,
		0.0000000000000000000000066174449004242214,
		0.0000000000000000000000033087224502121107,
		0.0000000000000000000000016543612251060553,
		0.0000000000000000000000008271806125530277,
		0.0000000000000000000000004135903062765138,
		0.0000000000000000000000002067951531382569,
		0.0000000000000000000000001033975765691285,
		0.0000000000000000000000000516987882845642,
		0.0000000000000000000000000258493941422821,
		0.0000000000000000000000000129246970711411,
		0.0000000000000000000000000064623485355705,
		0.0000000000000000000000000032311742677853,
		0.0000000000000000000000000016155871338926,
		0.0000000000000000000000000008077935669463,
		0.0000000000000000000000000004038967834732,
		0.0000000000000000000000000002019483917366,
		0.0000000000000000000000000001009741958683,
		0.0000000000000000000000000000504870979341,
		0.0000000000000000000000000000252435489671,
		0.0000000000000000000000000000126217744835,
		0.0000000000000000000000000000063108872418,
		0.0000000000000000000000000000031554436209,
		0.0000000000000000000000000000015777218104 };
int arcTansInt[] = { 843314856, 497837829, 263043836, 133525158, 67021686,
		33543515, 16775850, 8388437, 4194282, 2097149, 1048575, 524287, 262143,
		131071, 65535, 32767, 16383, 8191, 4095, 2047, 1023, 511, 255, 127, 63,
		31, 15, 7, 3, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0 };
int64_t arcTansLongInt[] = { 3622009730124208800LL, 2138197196257991700LL,
		1129764674086562800LL, 573486187337333400LL, 287855949760867800LL,
		144068300052059500LL, 72051727179705000LL, 36028062613110100LL,
		18014304036978600LL, 9007186378227700LL, 4503595336597500LL,
		2251795520815100LL, 1125895612923900LL, 562945658978300LL,
		281470682005500LL, 140733193519100LL, 70364449275900LL,
		35180077154300LL, 17587891093500LL, 8791798063100LL, 4393751547900LL,
		2194728290300LL, 1095216661500LL, 545460847100LL, 270582939900LL,
		133143986300LL, 64424509500LL, 30064771100LL, 12884901900LL,
		4294967300LL, 0LL, 0, 0LL, 0LL, 0LL, 0LL, 0LL, 0LL, 0LL, 0LL, 0LL, 0LL,
		0LL, 0LL, 0LL, 0LL, 0LL, 0LL, 0LL, 0LL, 0LL, 0LL, 0LL, 0LL, 0LL, 0, 0LL,
		0LL, 0LL, 0LL, 0LL, 0LL, 0LL, 0LL, 0LL, 0LL, 0LL, 0LL, 0LL, 0LL, 0LL,
		0LL, 0LL, 0LL, 0LL, 0LL, 0LL, 0LL, 0LL, 0, 0LL, 0LL, 0LL, 0LL, 0LL, 0LL,
		0LL, 0LL, 0LL, 0LL, 0LL, 0LL, 0LL, 0LL, 0LL, 0LL, 0LL, 0LL, 0LL, 0LL };
int kInversInt = 652032873;
int64_t kInversLongInt = 2800459870029452800LL;
int HALF_INTMAX = INT32_MAX / 2;
int64_t HALF_LONGINTMAX = INT64_MAX / 2;
double kInvers = 0.6072529350088812561694;
double pi = 3.1415926535897932384626433832795;
char fourTpi[] =
		"1010001011111001100000110110111001001110010001000001010100101001111"
				"11100001001110101011111010001111101010011010011011101110000001101101"
				"10110001010010101100110010011110001000011100100000100000111111110010"
				"10001011000111010101111011110101110111100010101100001101101110010010"
				"00110111000111010010000100100110111010010111000000000011001001001001"
				"01110111010100000100111010001100100100001110011111110000111011110101"
				"10001110010110001001010011010011100111110111010001000001000110101111"
				"10101001011101011101101000100100001001110100110011100011100000010011"
				"01011010001011111011111100100000100111001100100011101011000111001100"
				"00011010100110011100111110100100111001000010001011111100010111011110"
				"11111100100101000001110110001111111111000100101111111111111011110000"
				"00101100110000000111111101111001011110001000110001011010110100000101"
				"00110110100011111011011010011011001111110110011110010011111001011000"
				"01001101101110100111101000110001111110110011010011110010111111110101"
				"0001011010111010100100111101110101100011111101011";

double getMed(int e, int p, int n) {

	int start = n - e + 1;
	int end = -n - e - 1 - p;
	printf("%d %d\n", start, end);
	double number = 0;
	double pow = 2;
	int i;
	for (i = end; i <= start; i++) {
		number += (fourTpi[abs(i)] - '0') * pow;
		pow *= 2;
	}

	return number;
}

// Payne & Hanek algorithm
double reduceRange(double value) {
	int p = 40;
	int n = 53;
	int e = (int) fmax(log2(value) + 1, (double) n+1);
	int64_t X = 1LL * value * pow(2, n - 1 - e);
	double Med = getMed(e, p, n);
	double h = Med * X * pow(2, -2 * n - p);
	h = fmod(h, 1);

	return h * pi / 4;
}

double cordicSineOnDouble(double value) {
	int n = 0;
	double xn = kInvers;
	double yn = 0;
	double zn = reduceRange(value);
	double lastDiff = 1;
	double acc = 1 / pow(10, 10);
	double currentPow = 2;
	double factor = 0.5;
	while (fabs(lastDiff) >= acc && n < 50) {
		double d;
		if (zn >= 0) {
			d = 1;
		} else {
			d = -1;
		}
		currentPow *= factor;
		lastDiff = d * xn * currentPow;
		double xn1 = xn - d * yn * currentPow;
		yn += lastDiff;
		zn = zn - d * arcTans[n];
		xn = xn1;
		n++;
	}
	if (yn * yn + xn * xn != 1) {
		printf("Error! Checksum wrong: %F %F %.20F\n", yn, xn,
				yn * yn + xn * xn);
	}
	return yn;
}

int cordicSineOnInt(int value) {
	int n = 0;
	int xn = kInversInt;
	int yn = 0;
	int zn = value;
	int lastDiff = HALF_INTMAX;
	int acc = 1;
	while (abs(lastDiff) >= acc && n < 50) {
		int d;
		if (zn >= 0) {
			d = 1;
		} else {
			d = -1;
		}
		lastDiff = d * (xn >> n);
		int xn1 = xn - d * (yn >> n);
		yn += lastDiff;
		zn = zn - d * arcTansInt[n];
		xn = xn1;
		n++;
	}
	return yn;
}

double cordicBasedOnInt(double value) {

	int result = cordicSineOnInt(1 * HALF_INTMAX);
	return (double) result / HALF_INTMAX;
}

int64_t cordicSineOnLongInt(int64_t value) {
	int64_t n = 0;
	int64_t xn = kInversLongInt;
	int64_t yn = 0;
	int64_t zn = value;
	int64_t lastDiff = HALF_LONGINTMAX;
	int64_t acc = 1;
	while (abs(lastDiff) >= acc && n < 50) {
		int64_t d;
		if (zn >= 0) {
			d = 1;
		} else {
			d = -1;
		}
		lastDiff = d * (xn >> n);
		int64_t xn1 = xn - d * (yn >> n);
		yn += lastDiff;
		zn = zn - d * arcTansLongInt[n];
		xn = xn1;
		n++;
	}
	return yn;
}

double cordicBasedOnLongInt(double value) {

	int64_t result = cordicSineOnLongInt(1 * HALF_LONGINTMAX);
	return (double) result / HALF_LONGINTMAX;
}

double calculatePi() {

	int max = 10000;
	double sum = 0;
	int i;
	for (i = 1; i < max; ++i) {
		sum += 6.0 / (i * i);
	}
	return sqrt(sum);
}

int main(void) {

//	printf("%.10f\n",cordicBasedOnLongInt(1));
//	printf("%.10f\n",sin(1));

	double value = 1;
	int i;
	clock_t begin, between, end;
	begin = clock();
	double r1, r2;
	for (i = 0; i < 1000000; i++)
		r1 = sin(value);
	between = clock();
	for (i = 0; i < 1000000; i++)
		r2 = cordicBasedOnInt(value);
	end = clock();
	float t1 = between - begin;
	float t2 = end - between;
	printf("%.20F %.20F\n", t1, t2);
	printf("%.10F %.10F %.10F", r1, r2, sin(value));

//	printf("%.20F %.20F", cordicSineOnDouble(1), sin(1));
	return 0;
}
